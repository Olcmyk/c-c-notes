int i;
这句话是静态内存分配，在函数结束后就会被释放。所以容易引起一些难以察觉的错误。甚至在编译器中都不会报错。
静态内存分配是用栈的方式存储的，先分配的内存会后释放。动态内存分配则是哪怕函数终止也可以存在。

动态内存优点：
1.动态内存分配不需要事先指定长度（用sizeof可以提升可移植性）
2.内存可以手动释放
3.可以在函数运行中手动改变长度（realloc函数）
4.可以跨函数使用

malloc函数
  1.malloc是memory (内存) allocate (分配)的缩写
  2.先添加头文件malloc.h
  3.malloc函数只有一个形参，是整型
  4.malloc函数表示请求系统分配形参个字节
  5.malloc函数之返回第一个字节的地址
  6.如果只定义字节，那么并不能知道字节是什么变量，从而也就不能区别是怎样使用这些字节。所以要进行格式转换。
举例：
  int * p = (int *)malloc(sizeeof(int));
free函数
  free函数释放一段动态内存
  free(动态内存名)
realloc函数
  增加或减少一段动态内存
  realloc(pArr,100)
  （假如pArr原来是50，那么更改后前50个内存不变，假如原来是150，那么更改后会保留前100个内存）
  
注：一定要在malloc之后free，不然会导致电脑卡。而利用这个道理，我们也可以制作一个让自己电脑非常卡的程序。注意是非常卡而不是蓝屏，因为当电脑发现内存升满以后就不会继续分配空间了。

//会让电脑关机(原理:让内存条升满)
# include <stdio.h>
# include <malloc.h>

int main(void)
{
    while (1)
    {
        int *p = (int *)malloc(1000);
//最后面的数字越大关机越快
    }

    return 0;
}

注意2：建议在malloc时用
  int * p = (int *)malloc(sizeof(int));
  if(p==NULL)
    return p;//这里相当于return NULL
    
注意3：malloc前面可以使用强制内存转换，也可以不使用。在谭浩强的书中有原话：有些程序员坚持用程序转换，他们认为这样更规范。所以用不用都随意。
